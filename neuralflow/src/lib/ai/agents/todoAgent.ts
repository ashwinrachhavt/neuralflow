import { generateText } from "ai";
import { z } from "zod";
import { openai } from "../client";
import type { Agent, AgentContext, AgentResult, TaskDTO } from "../types";

const PlannedTaskSchema = z.object({
  title: z.string(),
  description: z.string().optional(),
  estimatePomodoros: z.number().int().positive().max(12).optional(),
  priority: z.enum(["LOW", "MEDIUM", "HIGH"]).default("MEDIUM"),
  tags: z.array(z.string()).optional(),
});

const TodoAgentOutputSchema = z.object({
  tasks: z.array(PlannedTaskSchema),
  rationale: z.string().optional(),
});

export const todoAgent: Agent = {
  name: "todoAgent",
  description: "Turn free-form brain dump into structured tasks for the Kanban board.",

  async run(ctx: AgentContext): Promise<AgentResult> {
    const input = ctx.brainDumpText ?? ctx.quickTodoText;
    if (!input) return { context: ctx };

    const prompt = `
You are Dao's flow-first todo planner.

User dump:
---
${input}
---

1. Extract concrete, actionable tasks.
2. Prefer small tasks (1â€“4 pomodoros).
3. Assign priority (LOW, MEDIUM, HIGH).
4. Return ONLY valid JSON in this format:

{
  "tasks": [
    {
      "title": "...",
      "description": "...",
      "estimatePomodoros": 1,
      "priority": "MEDIUM",
      "tags": ["job-search", "deep"]
    }
  ],
  "rationale": "..."
}`;

    const { text } = await generateText({
      model: openai("gpt-4.1-mini"),
      prompt,
    });

    // Try to robustly extract and parse JSON; default gracefully on failure
    const fencedMatch = text.match(/```(?:json)?\n([\s\S]*?)```/i);
    const braceMatch = text.match(/\{[\s\S]*\}$/);
    const candidate = fencedMatch?.[1] ?? braceMatch?.[0] ?? "{}";

    let parsed: z.SafeParseReturnType<any, any>;
    try {
      parsed = TodoAgentOutputSchema.safeParse(JSON.parse(candidate));
    } catch (_e) {
      parsed = { success: false, error: new z.ZodError([]) } as any;
    }
    if (!parsed.success) {
      // Fall back to empty task list to avoid breaking downstream flow
      if (process.env.NODE_ENV !== "production") {
        console.error("todoAgent parse error", parsed.error);
      }
      return {
        context: {
          ...ctx,
          generatedTasks: [],
          meta: { ...ctx.meta, todoAgentParseFailed: true },
        },
        debug: { rawModelOutput: text },
      };
    }

    const tasks: TaskDTO[] = parsed.data.tasks.map((t) => ({
      title: t.title,
      descriptionMarkdown: t.description ?? "",
      estimatedPomodoros: t.estimatePomodoros ?? null,
      priority: t.priority,
      tags: t.tags ?? [],
      status: "TODO",
      autoGenerated: true,
    }));

    return {
      context: {
        ...ctx,
        generatedTasks: tasks,
        meta: {
          ...ctx.meta,
          todoAgentRationale: parsed.data.rationale,
        },
      },
      debug: { rawModelOutput: text },
    };
  },
};
