import { NextResponse } from "next/server";

import { getOrCreateDbUser } from "@/lib/get-or-create-user";
import type { PlannedTask } from "@/lib/schemas/plan";
import { scheduleBlocks } from "@/lib/scheduler";
import { prisma } from "@/server/db/client";
import { getOrCreateDefaultBoard } from "@/server/db/boards";

export async function POST(req: Request) {
  const user = await getOrCreateDbUser();
  if (!user) {
    return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const rawTasks = (body?.tasks ?? []) as PlannedTask[];

  if (!Array.isArray(rawTasks) || rawTasks.length === 0) {
    return NextResponse.json({ message: "No tasks provided" }, { status: 400 });
  }

  // Determine or create a default board and TODO column for this user
  const boardRes = await getOrCreateDefaultBoard(user.id);
  if (!boardRes.ok) return NextResponse.json({ message: "Failed to resolve board" }, { status: 500 });
  const board = boardRes.value;
  const todoColumn = board.columns.find(c => c.name.toLowerCase() === "todo") ?? board.columns[0];

  // Persist tasks in order
  const createdTasks = await prisma.$transaction(async tx => {
    const results = [] as string[];
    for (const t of rawTasks) {
      const created = await tx.task.create({
        data: {
          board: { connect: { id: board.id } },
          column: { connect: { id: todoColumn.id } },
          title: t.title,
          descriptionMarkdown: t.description ?? "",
          priority: toPrismaPriority(t.priority),
          estimatedPomodoros: Math.max(1, Math.ceil((t.estimateMinutes ?? 25) / 25)),
          autoGenerated: true,
        },
      });
      results.push(created.id);
    }
    return results;
  });

  const blocks = scheduleBlocks(rawTasks);

  return NextResponse.json({ ok: true, created: createdTasks.length, focusBlocks: blocks.filter(b => b.type === "focus").length });
}

function toPrismaPriority(p: PlannedTask["priority"]) {
  switch (p) {
    case "high":
      return "HIGH" as const;
    case "low":
      return "LOW" as const;
    default:
      return "MEDIUM" as const;
  }
}

// moved to lib/board.ts
