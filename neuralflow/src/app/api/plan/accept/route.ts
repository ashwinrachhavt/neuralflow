import { NextResponse } from "next/server";

import { prisma } from "@/lib/prisma";
import { getOrCreateDbUser } from "@/lib/get-or-create-user";
import type { PlannedTask } from "@/lib/schemas/plan";
import { scheduleBlocks } from "@/lib/scheduler";
import { getOrCreateDefaultBoard } from "@/lib/board";

export async function POST(req: Request) {
  const user = await getOrCreateDbUser();
  if (!user) {
    return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const rawTasks = (body?.tasks ?? []) as PlannedTask[];

  if (!Array.isArray(rawTasks) || rawTasks.length === 0) {
    return NextResponse.json({ message: "No tasks provided" }, { status: 400 });
  }

  // Determine or create a default board and TODO column for this user
  const board = await getOrCreateDefaultBoard(user.id);
  const todoColumn = board.columns.find(c => c.name.toLowerCase() === "todo") ?? board.columns[0];

  // Persist tasks in order
  const createdTasks = await prisma.$transaction(
    rawTasks.map((t, index) =>
      prisma.task.create({
        data: {
          boardId: board.id,
          columnId: todoColumn.id,
          title: t.title,
          descriptionMarkdown: t.description ?? "",
          priority: toPrismaPriority(t.priority),
          estimatedPomodoros: Math.max(1, Math.ceil((t.estimateMinutes ?? 25) / 25)),
          autoGenerated: true,
          // Preserve order via createdAt (already sequential). If ordering support added later, map here.
        },
      }),
    ),
  );

  const blocks = scheduleBlocks(rawTasks);

  return NextResponse.json({ ok: true, created: createdTasks.length, focusBlocks: blocks.filter(b => b.type === "focus").length });
}

function toPrismaPriority(p: PlannedTask["priority"]) {
  switch (p) {
    case "high":
      return "HIGH" as const;
    case "low":
      return "LOW" as const;
    default:
      return "MEDIUM" as const;
  }
}

// moved to lib/board.ts
